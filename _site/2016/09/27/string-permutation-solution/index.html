<h3 id="题目-字符串的排列">题目: 字符串的排列</h3>

<ul>
  <li>热度指数：5777    时间限制：1秒    空间限制：32768K</li>
  <li>本题知识点： <a href="http://www.nowcoder.com/questionCenter?questionTypes=000100&amp;mutiTagIds=579">字符串</a></li>
</ul>

<h2 id="题目描述">题目描述</h2>

<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。 </p>

<p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。 结果请按字母顺序输出。</p>

<p><strong>输入描述:</strong><code class="highlighter-rouge">输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。</code></p>

<h3 id="分析">分析:</h3>
<p>方法1: 递归解法</p>

<p>方法2: dfs</p>

<p>方法3: 先对输入的字符串进行重新排序, 然后使用stl算法库中的函数next_permutation()按顺序得到各个字符串, 并依次存入vector中…</p>

<p>按方法3给出的已AC代码:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include&lt;string&gt;
#include &lt;algorithm&gt;
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">comp</span><span class="p">(</span><span class="kt">char</span> <span class="n">a</span><span class="p">,</span> <span class="kt">char</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">&lt;</span><span class="n">b</span><span class="p">;</span>
<span class="p">}</span>  <span class="c1">// sort()重载的函数不能写在class Solution的内部, class内部的函数指针和外部的函数指针类型不一样
</span>
<span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">Permutation</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vect</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="n">vect</span><span class="p">;</span>        

    <span class="n">sort</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comp</span><span class="p">);</span>
    <span class="c1">// 也可使用匿名函数: sort(str.begin(), str.end(), [](char a, char b){return a&lt;b;});    
</span>    <span class="k">do</span><span class="p">{</span>
		<span class="n">string</span> <span class="n">sstr</span><span class="p">;</span>
		<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">sstr</span> <span class="o">+=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">vect</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">sstr</span><span class="p">);</span>
		<span class="n">sstr</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="p">}</span>
	<span class="k">while</span><span class="p">(</span><span class="n">next_permutation</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="p">));</span> <span class="c1">// 使用do...while保证对第一个也有效
</span>    <span class="k">return</span> <span class="n">vect</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="c1">// 以下为测试
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">Solution</span> <span class="n">sol</span><span class="p">;</span>
	<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">sol</span><span class="p">.</span><span class="n">Permutation</span><span class="p">(</span><span class="s">"acb"</span><span class="p">);</span>
	<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span><span class="o">:</span> <span class="n">res</span><span class="p">)</span>
		<span class="n">cout</span><span class="o">&lt;&lt;</span><span class="n">it</span><span class="o">&lt;&lt;</span><span class="sc">' '</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>next_permutation() 函数原型:</p>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">next_permutation</span><span class="p">(</span>
      <span class="n">BidirectionalIterator</span> <span class="n">_First</span><span class="p">,</span>
      <span class="n">BidirectionalIterator</span> <span class="n">_Last</span><span class="p">,</span>
      <span class="n">BinaryPredicate</span> <span class="n">_Comp</span>
 <span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>对于第二个重载函数的第三个参数, 默认比较顺序为小于. 如果找到下一个序列, 则返回真, 否则返回假.</p>

<p>用next_permutation和prev_permutation求排列组合很方便,  但是要记得包含头文件<code class="highlighter-rouge">#include &lt;algorithm&gt;</code>.</p>

<p>虽然最后一个排列没有下一个排列, 用next_permutation会返回false, 但是使用了这个方法后，序列会变成字典序列的第一个, 如cba变成abc, prev_permutation同理。</p>
